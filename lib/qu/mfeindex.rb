require 'qu/utils'
require 'qu/cmdwrapper'

require_relative "mfeindex/data"
require_relative "mfeindex/version"
require 'json'

module Qu
  module Mfeindex
    # Your code goes here...

    module_function

    def get_big_db_dir(db)
      db + BIG_DB
    end

    def check_db(db_list)
      new_db_list = []

      db_list.each do |db|
        big_db_dir = get_big_db_dir(db)
        if db_indexed?(db)
          new_db_list << db 
          next
        elsif File.directory?(big_db_dir)
          Dir.foreach(big_db_dir).each do |small_file|
            prefix = File.basename(db)
            next small_file unless small_file =~ /^#{prefix}\.\d$/
            new_db_list << File.join(big_db_dir, small_file)
          end
        elsif !File.exists?(db)
          $stderr.puts "Error: #{db} is not exists."  
          exit
        elsif File.size(db) > BIG_DB_SPLIT_CUTOFF
          $stderr.puts "Warning: #{db} is too large, please use mfepindex to index the db first."
          exit
        else
          new_db_list << db
          next
        end
      end
      new_db_list
    end

    def db_indexed?(db)
      File.exist?(db + DB_SQLITE3) and File.exist?(db + DB_JSON) and File.exist?(db + DB_2BIT)
    end

    def create_db_seq_desc(db)
      info_json = {}

      Bio::FlatFile.new(Bio::FastaFormat, File.open(db)).each do |record|
        info_json[record.entry_name] = {'id' => record.entry_name, 'desc' => record.desc, 'size' => record.naseq.size}
      end

      File.open(db + DB_JSON, 'w') do |fh|
        fh.write(JSON.dump(info_json))
      end
    end

    def MFEprimerIndex(fasta_file, k = 9, mem_limit = 200, reindex = false)
      return if !reindex and db_indexed?(fasta_file)

      unless File.exists?(fasta_file)
        $stderr.puts "Error: #{fasta_file} is not exists." 
        exit
      end
      info_json = {}

      uni_fasta = fasta_file + '.unifasta'

      File.open(uni_fasta, 'w') do |fh|
        Bio::FlatFile.new(Bio::FastaFormat, File.open(fasta_file)).each_with_index do |record, index|
          info_json[index] = {'id' => record.entry_name, 'desc' => record.desc, 'size' => record.naseq.size}
          fh.write ">#{index}\n#{record.naseq}\n"
        end
      end

      File.open(fasta_file + DB_JSON, 'w') do |fh|
        fh.write(JSON.dump(info_json))
      end

      Qu::Cmdwrapper::faToTwoBit(uni_fasta, fasta_file + DB_2BIT)

      cmd = File.join(__dir__, 'pymfeindex')
      $stderr.puts "Begin index database: #{fasta_file}"
      `#{cmd} -f #{uni_fasta} -m #{mem_limit} -k #{k} -o #{fasta_file + DB_SQLITE3}`
      begin
        File.delete(uni_fasta)
      rescue
        if File.exists?(uni_fasta)
          $stderr.puts "You can delete the file #{uni_fasta} by hand."
        end
      end
      $stderr.puts "Done index database: #{fasta_file}"
    end

    def int2dna(int, k=9, base_number=4)
      seqint = int.to_s(base_number)
      dna = ""
      (0...seqint.length).each do |index|
       dna += D2I[seqint[index].to_i]    
     end 
     return 'A' * (k - seqint.length) + dna   
    end

    def dna2int(dna, base_number=4)
      plus_int = 0
      dna = dna.upcase
      # This is plus strand position
      dna.each_char.with_index do |base, index|
        plus_int += D2I[base] * base_number ** (dna.length - 1 - index)
      end
      return plus_int
    end

    def split_pos(data)
      # Split position data from SQLite3 database which generated by mfeindex
      pos_hash = {}
      data.split(';').each do |hit_record|
        hit_id, hit_pos = hit_record.split(':')
        pos_hash[hit_id.to_i] = hit_pos.split(',').collect {|pos| pos.to_i}
      end

      return pos_hash
    end

    def detect_kvalue(db_file)
      db = SQLite3::Database.new(db_file)

      begin
        mer_num = db.execute("select count(*) from pos")[0][0]
        kvalue = Math.log(mer_num, 4).to_i
      rescue Exception => e
        kvalue = 9
      end
      
      return kvalue
    end

    def get_kvalue(db_list)
      kmer_list = []
      db_list.each do |db|
        if db_indexed?(db)
          kmer_list << detect_kvalue(db + DB_SQLITE3)
        end
      end
      kmer_list.uniq!

      kvalue = 9
      
      if kmer_list.size > 1
        $stderr.puts "Different index kmer value among #{@opts.db}."
        exit
      elsif kmer_list.size == 1
        kvalue = kmer_list[0]
      else
        kvalue = 9
      end
      kvalue
    end
    

    def query_sqlite3(db_file, mer_id_list)
      pos = {}
      db = SQLite3::Database.new(db_file)
      db.execute("select mer_id, plus, minus from pos where mer_id in (#{mer_id_list.join(', ')})") do |row|
        mer_id, plus, minus = row
        pos[mer_id] ||= {}
        pos[mer_id][:plus] = split_pos(plus) unless plus.empty?
        pos[mer_id][:minus] = split_pos(minus) unless minus.empty?
      end

      return pos
    end
  end
end
